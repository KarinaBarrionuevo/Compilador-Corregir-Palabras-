
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20141202 (SVN rev 60)
//----------------------------------------------------

package compiladorcorregir;

import java_cup.runtime.*;
import java.io.FileReader;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20141202 (SVN rev 60) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class AnalizadorSintactico extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return sym.class;
}

  /** Default constructor. */
  public AnalizadorSintactico() {super();}

  /** Constructor which sets the default scanner. */
  public AnalizadorSintactico(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public AnalizadorSintactico(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\011\000\002\002\004\000\002\002\005\000\002\002" +
    "\004\000\002\002\003\000\002\003\004\000\002\006\003" +
    "\000\002\004\004\000\002\007\003\000\002\005\005" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\021\000\006\004\010\005\006\001\002\000\004\002" +
    "\023\001\002\000\004\002\ufffe\001\002\000\004\007\021" +
    "\001\002\000\004\006\020\001\002\000\006\005\012\007" +
    "\011\001\002\000\004\006\017\001\002\000\004\007\015" +
    "\001\002\000\004\006\014\001\002\000\004\002\000\001" +
    "\002\000\004\006\ufffc\001\002\000\004\006\ufffd\001\002" +
    "\000\004\002\ufff9\001\002\000\004\002\uffff\001\002\000" +
    "\004\006\ufffa\001\002\000\004\006\ufffb\001\002\000\004" +
    "\002\001\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\021\000\010\002\003\004\006\005\004\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\007\021\001\001" +
    "\000\002\001\001\000\004\003\012\001\001\000\002\001" +
    "\001\000\004\006\015\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$AnalizadorSintactico$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$AnalizadorSintactico$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$AnalizadorSintactico$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}




    /* Reporte de error encontrado. */
    public void report_error(String message, Object info) {
        
        StringBuilder m = new StringBuilder("Error");
        //Condición que permite saber si el info pertenece a un simbolo o no
        if (info instanceof java_cup.runtime.Symbol) {
            /*Aquí se hace un casting para convertir el objeto info a un
              símbolo*/

          java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            
            /*Aqui encuentro la fila y columna, según la ubicación del símbolo 
            en el archivo .txt de entrada  */
            int fila=s.left+1;
            int columna=s.right+1;

            /*En esta parte añadimos al mensaje de error, la fila y la columna,
               indicacndo la ubicación del error en el archivo de entrada*/
            if (s.left >= 0) {                
                m.append(" en la línea "+(fila));
                if (s.right >= 0)
                    m.append(", columna "+(columna));
            }
        }
        
        /*---------DETECCIÓN DE ERRORES----------------------------*/
        //almaceno el valor del objeto info en un variable String
        String infor = info + "";
        //Se crea un arreglo de tipo String para guardar valor de info sin el # 
        String[] tokens = infor.split("#");        
        //En una variable entera se almacen el valor obtenido del arreglo tokens en la posición 1
        int valor=Integer.parseInt(tokens[1]);

/*       Se toma el valor entero de la  variable CORREGIR  de la clases sym , donde están todos los símbolos definidos. 
        La finalidad de obtener este valor es compararlo con el valor obtenido del arreglo para determinar si este es el palabra 
        reservada que falta en la sintaxis para que esta sea correcta; en el caso de ser iguales almacena un mensaje  en un variable String
    */

        if (sym.CORREGIR == valor) {
            message = "falta operador : corregir_cadena";
            
       
        } else {
             /*       Se toma el valor entero de la  variable ALFABETO  de la clases sym , donde están todos los símbolos definidos. 
        La finalidad de obtener este valor es compararlo con el valor obtenido del arreglo para determinar si este es el palabra 
         que falta en la sintaxis para que esta sea correcta; en el caso de ser iguales almacena un mensaje  en un variable String
        */
            if (sym.ALFABETO== valor) {
                message = "falta la cadena que desea corregir";
        

            } else {

                 /* Se toma el valor entero de la  variable EOF(FIN DE LINEA)  de la clases sym , donde están todos los símbolos definidos. 
        La finalidad de obtener este valor es compararlo con el valor obtenido del arreglo para determinar si este es el palabra 
         que falta en la sintaxis para que esta sea correcta; en el caso de ser iguales almacena un mensaje  en un variable String
         */
                if (sym.EOF == valor) {
                    message = "falta fin de linea:";
     /*       Se toma el valor entero de la  variable BARRA  de la clases sym , donde están todos los símbolos definidos. 
        La finalidad de obtener este valor es compararlo con el valor obtenido del arreglo para determinar si este es el palabra 
         que falta en la sintaxis para que esta sea correcta; en el caso de ser iguales almacena un mensaje  en un variable String
    */
                }else{
                    if (sym.BARRA == valor) {
                    message = "MAL INGRESADO";
                    
                }

                }
                
            }
        }
     
//Aqui se presenta el mensaje de error y su ubicación
        m.append(" : "+message);
        System.err.println(m);
    }

   
    /* Cuando se encuentra un error de donde el sistema no puede
        recuperarse, se lanza un error fatal. Se despliega el mensaje
        de error y se finaliza la ejecucion. */
public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

 
   /* METODO PARA CORREGIR LA PALABRA INGRESADA - RECIBO COMO PARAMETRO EL TOKEN
     AL  QUE SE ENCUENTRA ASOCIADO LA CADENA A CORREGIR Y DEVUELVO LA CADENA CORREGIDA*/
    public String corregir(token palabra){
        /* Asigno la cadena ingresada a una varible de tipo string */
        String c1=palabra.getCadena();
        String cade = c1;
        String cadenafinal="";
        /* A la varible cade de tipo string le asigno una subcadena de la palabra ingresada  
        que no contenga unicamente la terminologia cion o sion   */
        cade = c1.substring(0, c1.length() - 4);
        //System.out.println("esta es la subcadena: " + cade);
/*Comparo la subcadena para verificar que palabra  es la que se tiene que corregir */
        if (cade.equalsIgnoreCase("can")) {
           // System.out.println("cancion");
    /*A la varible cadenafinal le asigno la palabra escrita de forma correcta */
            cadenafinal="cancion";
        } if (cade.equalsIgnoreCase("oposi")) {
             //   System.out.println("oposicion");
            cadenafinal="oposicion";
        }if (cade.equalsIgnoreCase("ac")) {
             //   System.out.println("oposicion");
            cadenafinal="accion";
        }  if (cade.equalsIgnoreCase("adi")) {
             //   System.out.println("oposicion");
            cadenafinal="adicion";
        } if (cade.equalsIgnoreCase("frac")) {
             //   System.out.println("oposicion");
            cadenafinal="fraccion";
        } if (cade.equalsIgnoreCase("ilu")) {
             //   System.out.println("oposicion");
            cadenafinal="ilusion";
        } if (cade.equalsIgnoreCase("mi")) {
             //   System.out.println("oposicion");
            cadenafinal="mision";
        } if (cade.equalsIgnoreCase("vi")) {
             //   System.out.println("oposicion");
            cadenafinal="vision";
        } if (cade.equalsIgnoreCase("ver")) {
             //   System.out.println("oposicion");
            cadenafinal="version";
        } if (cade.equalsIgnoreCase("deci")) {
             //   System.out.println("oposicion");
            cadenafinal="decision";
        } 
         
         

        return cadenafinal;

    }



/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$AnalizadorSintactico$actions {
  private final AnalizadorSintactico parser;

  /** Constructor */
  CUP$AnalizadorSintactico$actions(AnalizadorSintactico parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$AnalizadorSintactico$do_action_part00000000(
    int                        CUP$AnalizadorSintactico$act_num,
    java_cup.runtime.lr_parser CUP$AnalizadorSintactico$parser,
    java.util.Stack            CUP$AnalizadorSintactico$stack,
    int                        CUP$AnalizadorSintactico$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$AnalizadorSintactico$result;

      /* select the action based on the action number */
      switch (CUP$AnalizadorSintactico$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= programa EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.elementAt(CUP$AnalizadorSintactico$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.elementAt(CUP$AnalizadorSintactico$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$AnalizadorSintactico$stack.elementAt(CUP$AnalizadorSintactico$top-1)).value;
		RESULT = start_val;
              CUP$AnalizadorSintactico$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.elementAt(CUP$AnalizadorSintactico$top-1)), ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$AnalizadorSintactico$parser.done_parsing();
          return CUP$AnalizadorSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // programa ::= IMPRIMIR expresion1 BARRA 
            {
              Object RESULT =null;

              CUP$AnalizadorSintactico$result = parser.getSymbolFactory().newSymbol("programa",0, ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.elementAt(CUP$AnalizadorSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.peek()), RESULT);
            }
          return CUP$AnalizadorSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // programa ::= expresion2 BARRA 
            {
              Object RESULT =null;

              CUP$AnalizadorSintactico$result = parser.getSymbolFactory().newSymbol("programa",0, ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.elementAt(CUP$AnalizadorSintactico$top-1)), ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.peek()), RESULT);
            }
          return CUP$AnalizadorSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // programa ::= expresion3 
            {
              Object RESULT =null;

              CUP$AnalizadorSintactico$result = parser.getSymbolFactory().newSymbol("programa",0, ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.peek()), RESULT);
            }
          return CUP$AnalizadorSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // expresion1 ::= CORREGIR reservada1 
            {
              Object RESULT =null;

              CUP$AnalizadorSintactico$result = parser.getSymbolFactory().newSymbol("expresion1",1, ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.elementAt(CUP$AnalizadorSintactico$top-1)), ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.peek()), RESULT);
            }
          return CUP$AnalizadorSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // reservada1 ::= ALFABETO 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.peek()).right;
		token a = (token)((java_cup.runtime.Symbol) CUP$AnalizadorSintactico$stack.peek()).value;
		 System.out.println("PALABRA INGRESADA: "+a.getCadena());System.out.println("PALABRA CORREGIDA: "
    +new AnalizadorSintactico().corregir(a));
              CUP$AnalizadorSintactico$result = parser.getSymbolFactory().newSymbol("reservada1",4, ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.peek()), RESULT);
            }
          return CUP$AnalizadorSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // expresion2 ::= CORREGIR reservada2 
            {
              Object RESULT =null;

              CUP$AnalizadorSintactico$result = parser.getSymbolFactory().newSymbol("expresion2",2, ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.elementAt(CUP$AnalizadorSintactico$top-1)), ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.peek()), RESULT);
            }
          return CUP$AnalizadorSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // reservada2 ::= ALFABETO 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.peek()).right;
		token a = (token)((java_cup.runtime.Symbol) CUP$AnalizadorSintactico$stack.peek()).value;
		 System.out.println("PALABRA INGRESADA: "+a.getCadena());
              CUP$AnalizadorSintactico$result = parser.getSymbolFactory().newSymbol("reservada2",5, ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.peek()), RESULT);
            }
          return CUP$AnalizadorSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // expresion3 ::= IMPRIMIR ALFABETO BARRA 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.elementAt(CUP$AnalizadorSintactico$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.elementAt(CUP$AnalizadorSintactico$top-1)).right;
		token a = (token)((java_cup.runtime.Symbol) CUP$AnalizadorSintactico$stack.elementAt(CUP$AnalizadorSintactico$top-1)).value;
		CUP$AnalizadorSintactico$result = parser.getSymbolFactory().newSymbol("expresion3",3,
 ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.elementAt(CUP$AnalizadorSintactico$top-1)), ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.peek()), RESULT);
/* Aqui se llama al método report_error, que recibe como parámetros el mensaje y el obejeto de tipo symbol que en este caso es result*/
parser.report_error ("c",CUP$AnalizadorSintactico$result);
              CUP$AnalizadorSintactico$result = parser.getSymbolFactory().newSymbol("expresion3",3, ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.elementAt(CUP$AnalizadorSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$AnalizadorSintactico$stack.peek()), RESULT);
            }
          return CUP$AnalizadorSintactico$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$AnalizadorSintactico$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$AnalizadorSintactico$do_action(
    int                        CUP$AnalizadorSintactico$act_num,
    java_cup.runtime.lr_parser CUP$AnalizadorSintactico$parser,
    java.util.Stack            CUP$AnalizadorSintactico$stack,
    int                        CUP$AnalizadorSintactico$top)
    throws java.lang.Exception
    {
              return CUP$AnalizadorSintactico$do_action_part00000000(
                               CUP$AnalizadorSintactico$act_num,
                               CUP$AnalizadorSintactico$parser,
                               CUP$AnalizadorSintactico$stack,
                               CUP$AnalizadorSintactico$top);
    }
}

}
